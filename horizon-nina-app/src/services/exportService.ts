import { Platform } from "react-native";
import * as FileSystem from "expo-file-system";
import * as Sharing from "expo-sharing";
import { HorizonData, ExportOptions } from "../types";
import { EXPORT_CONFIG } from "../constants";
import { interpolateGaps } from "../utils/calculations";

class ExportService {
  async generateHznFile(
    horizon: HorizonData,
    options: ExportOptions
  ): Promise<string> {
    try {
      const processedPoints = options.interpolateGaps
        ? interpolateGaps(horizon.points, options.resolution)
        : horizon.points;

      const content = this.formatHorizonData(processedPoints, options, horizon);
      const filename = `${
        EXPORT_CONFIG.DEFAULT_FILENAME
      }_${new Date().getTime()}`; // No extension for SAF initially

      // Try Storage Access Framework (Android)
      if (Platform.OS === "android" && FileSystem.StorageAccessFramework) {
        try {
          const permissions =
            await FileSystem.StorageAccessFramework.requestDirectoryPermissionsAsync();

          if (permissions.granted) {
            const uri = await FileSystem.StorageAccessFramework.createFileAsync(
              permissions.directoryUri,
              filename,
              "text/plain" // MIME type
            );

            await FileSystem.writeAsStringAsync(uri, content, {
              encoding: FileSystem.EncodingType.UTF8,
            });
            return uri;
          }
        } catch (safError) {
          console.warn("SAF failed, falling back to cache:", safError);
        }
      }

      // Fallback to Cache/Document Directory (iOS or SAF denied/failed)
      const extension = EXPORT_CONFIG.FILE_EXTENSION;
      const fullFilename = filename + extension;

      let directory = FileSystem.cacheDirectory;
      if (!directory) {
        console.warn(
          "Cache directory not available, falling back to document directory"
        );
        directory = FileSystem.documentDirectory;
      }

      if (!directory) {
        throw new Error(
          "No writable directory available (cache and document directories are null)"
        );
      }

      const filePath = `${directory}${fullFilename}`;

      console.log("Writing to file:", filePath);
      await FileSystem.writeAsStringAsync(filePath, content, {
        encoding: FileSystem.EncodingType.UTF8,
      });

      // Verify file exists
      const info = await FileSystem.getInfoAsync(filePath);
      if (!info.exists) {
        throw new Error("File was not written successfully");
      }

      return filePath;
    } catch (error) {
      console.error("Error generating HZN file:", error);
      throw error;
    }
  }

  formatHorizonData(
    points: any[],
    options: ExportOptions,
    horizon: HorizonData
  ): string {
    const header = this.generateHeader(horizon, options, points.length);

    if (options.format === "detailed") {
      return this.formatDetailedData(header, points, options);
    } else {
      return this.formatStandardData(header, points, options);
    }
  }

  private generateHeader(
    horizon: HorizonData,
    options: ExportOptions,
    pointCount: number
  ): string {
    const location = horizon.location || {
      latitude: 0,
      longitude: 0,
      altitude: 0,
    };
    const date = new Date(horizon.createdAt).toISOString();

    return `# N.I.N.A. Horizon File
# Generated by Horizon NINA App
# Location: ${location.latitude}, ${location.longitude}, ${
      location.altitude || 0
    }
# Date: ${date}
# Resolution: ${options.resolution} degrees
# Points: ${pointCount}
# Format: ${options.format}
# Interpolated: ${options.interpolateGaps}
# Metadata: ${options.includeMetadata ? "Included" : "Excluded"}

Latitude: ${location.latitude}
Longitude: ${location.longitude}
Altitude: ${location.altitude || 0}
Date: ${date}
Resolution: ${options.resolution}
Points: ${pointCount}
`;
  }

  private formatStandardData(
    header: string,
    points: any[],
    options: ExportOptions
  ): string {
    let dataSection = "\n# Azimuth(deg) Altitude(deg)\n";

    // Group points by azimuth and find minimum altitude for each direction
    const azimuthGroups = new Map<number, number[]>();

    points.forEach((point) => {
      const azimuth =
        Math.round(point.azimuth / options.resolution) * options.resolution;
      if (!azimuthGroups.has(azimuth)) {
        azimuthGroups.set(azimuth, []);
      }
      azimuthGroups.get(azimuth)!.push(point.altitude);
    });

    // Generate complete 360-degree horizon
    for (let az = 0; az < 360; az += options.resolution) {
      const group = azimuthGroups.get(az);
      let altitude: number;

      if (group && group.length > 0) {
        altitude = Math.min(...group);
      } else {
        // Interpolate or use default
        altitude = this.interpolateMissingAltitude(
          az,
          azimuthGroups,
          options.resolution
        );
      }
      if (!isFinite(altitude)) altitude = 0;
      if (altitude < 0) altitude = 0;
      if (altitude > 90) altitude = 90;
      dataSection += `${az.toFixed(1)} ${altitude.toFixed(1)}\n`;
    }

    return header + dataSection;
  }

  private formatDetailedData(
    header: string,
    points: any[],
    options: ExportOptions
  ): string {
    let dataSection = "\n# Azimuth(deg) Altitude(deg) Timestamp Accuracy\n";

    points.forEach((point) => {
      dataSection += `${point.azimuth.toFixed(1)} ${point.altitude.toFixed(
        1
      )} ${point.timestamp} ${point.accuracy.toFixed(2)}\n`;
    });

    return header + dataSection;
  }

  private interpolateMissingAltitude(
    targetAz: number,
    azimuthGroups: Map<number, number[]>,
    resolution: number
  ): number {
    // Find nearest neighbors
    const neighbors: { az: number; alt: number; distance: number }[] = [];

    azimuthGroups.forEach((altitudes, az) => {
      const distance = Math.abs(az - targetAz);
      const minAlt = Math.min(...altitudes);
      neighbors.push({ az, alt: minAlt, distance });
    });

    if (neighbors.length === 0) return 0;

    // Sort by distance and take nearest 2
    neighbors.sort((a, b) => a.distance - b.distance);
    const nearest = neighbors.slice(0, 2);

    if (nearest.length === 1) return nearest[0].alt;

    // Simple linear interpolation
    const totalDistance = nearest[0].distance + nearest[1].distance;
    if (totalDistance === 0) return nearest[0].alt;

    const weight1 = 1 - nearest[0].distance / totalDistance;
    const weight2 = 1 - nearest[1].distance / totalDistance;

    return (
      (nearest[0].alt * weight1 + nearest[1].alt * weight2) /
      (weight1 + weight2)
    );
  }

  async shareFile(filePath: string): Promise<void> {
    try {
      // If it is a SAF URI (content://), we don't need to share it, it is already saved
      if (filePath.startsWith("content://")) {
        return;
      }

      const isAvailable = await Sharing.isAvailableAsync();
      if (!isAvailable) {
        throw new Error("Sharing is not available on this device");
      }

      console.log("Sharing file:", filePath);
      await Sharing.shareAsync(filePath, {
        mimeType: "text/plain",
        dialogTitle: "Share Horizon File",
        UTI: "public.plain-text", // More standard UTI
      });
    } catch (error) {
      console.error("Error sharing file:", error);
      throw error; // Re-throw the original error for better debugging in the UI
    }
  }

  async getExportDirectory(): Promise<string> {
    return FileSystem.documentDirectory || "";
  }

  async listExportFiles(): Promise<string[]> {
    try {
      const dir = await this.getExportDirectory();
      const files = await FileSystem.readDirectoryAsync(dir);
      return files.filter((file) =>
        file.endsWith(EXPORT_CONFIG.FILE_EXTENSION)
      );
    } catch (error) {
      console.error("Error listing export files:", error);
      return [];
    }
  }

  async deleteExportFile(filename: string): Promise<void> {
    try {
      const filePath = `${FileSystem.documentDirectory}${filename}`;
      await FileSystem.deleteAsync(filePath);
    } catch (error) {
      console.error("Error deleting export file:", error);
      throw new Error("Failed to delete export file");
    }
  }
}

export const exportService = new ExportService();
